# LocalStack Resource Provider Scaffolding v2
from __future__ import annotations

import json
from pathlib import Path
from typing import Optional, TypedDict

import localstack.services.cloudformation.provider_utils as util
from localstack.services.cloudformation.resource_provider import (
    OperationStatus,
    ProgressEvent,
    ResourceProvider,
    ResourceRequest,
)
from localstack.utils import common


class EventsRuleProperties(TypedDict):
    Arn: Optional[str]
    Description: Optional[str]
    EventBusName: Optional[str]
    EventPattern: Optional[dict]
    Id: Optional[str]
    Name: Optional[str]
    RoleArn: Optional[str]
    ScheduleExpression: Optional[str]
    State: Optional[str]
    Targets: Optional[list[Target]]


class HttpParameters(TypedDict):
    HeaderParameters: Optional[dict]
    PathParameterValues: Optional[list[str]]
    QueryStringParameters: Optional[dict]


class DeadLetterConfig(TypedDict):
    Arn: Optional[str]


class RunCommandTarget(TypedDict):
    Key: Optional[str]
    Values: Optional[list[str]]


class RunCommandParameters(TypedDict):
    RunCommandTargets: Optional[list[RunCommandTarget]]


class InputTransformer(TypedDict):
    InputTemplate: Optional[str]
    InputPathsMap: Optional[dict]


class KinesisParameters(TypedDict):
    PartitionKeyPath: Optional[str]


class RedshiftDataParameters(TypedDict):
    Database: Optional[str]
    Sql: Optional[str]
    DbUser: Optional[str]
    SecretManagerArn: Optional[str]
    StatementName: Optional[str]
    WithEvent: Optional[bool]


class SqsParameters(TypedDict):
    MessageGroupId: Optional[str]


class PlacementConstraint(TypedDict):
    Expression: Optional[str]
    Type: Optional[str]


class PlacementStrategy(TypedDict):
    Field: Optional[str]
    Type: Optional[str]


class CapacityProviderStrategyItem(TypedDict):
    CapacityProvider: Optional[str]
    Base: Optional[int]
    Weight: Optional[int]


class Tag(TypedDict):
    Key: Optional[str]
    Value: Optional[str]


class AwsVpcConfiguration(TypedDict):
    Subnets: Optional[list[str]]
    AssignPublicIp: Optional[str]
    SecurityGroups: Optional[list[str]]


class NetworkConfiguration(TypedDict):
    AwsVpcConfiguration: Optional[AwsVpcConfiguration]


class EcsParameters(TypedDict):
    TaskDefinitionArn: Optional[str]
    CapacityProviderStrategy: Optional[list[CapacityProviderStrategyItem]]
    EnableECSManagedTags: Optional[bool]
    EnableExecuteCommand: Optional[bool]
    Group: Optional[str]
    LaunchType: Optional[str]
    NetworkConfiguration: Optional[NetworkConfiguration]
    PlacementConstraints: Optional[list[PlacementConstraint]]
    PlacementStrategies: Optional[list[PlacementStrategy]]
    PlatformVersion: Optional[str]
    PropagateTags: Optional[str]
    ReferenceId: Optional[str]
    TagList: Optional[list[Tag]]
    TaskCount: Optional[int]


class BatchRetryStrategy(TypedDict):
    Attempts: Optional[int]


class BatchArrayProperties(TypedDict):
    Size: Optional[int]


class BatchParameters(TypedDict):
    JobDefinition: Optional[str]
    JobName: Optional[str]
    ArrayProperties: Optional[BatchArrayProperties]
    RetryStrategy: Optional[BatchRetryStrategy]


class SageMakerPipelineParameter(TypedDict):
    Name: Optional[str]
    Value: Optional[str]


class SageMakerPipelineParameters(TypedDict):
    PipelineParameterList: Optional[list[SageMakerPipelineParameter]]


class RetryPolicy(TypedDict):
    MaximumEventAgeInSeconds: Optional[int]
    MaximumRetryAttempts: Optional[int]


class Target(TypedDict):
    Arn: Optional[str]
    Id: Optional[str]
    BatchParameters: Optional[BatchParameters]
    DeadLetterConfig: Optional[DeadLetterConfig]
    EcsParameters: Optional[EcsParameters]
    HttpParameters: Optional[HttpParameters]
    Input: Optional[str]
    InputPath: Optional[str]
    InputTransformer: Optional[InputTransformer]
    KinesisParameters: Optional[KinesisParameters]
    RedshiftDataParameters: Optional[RedshiftDataParameters]
    RetryPolicy: Optional[RetryPolicy]
    RoleArn: Optional[str]
    RunCommandParameters: Optional[RunCommandParameters]
    SageMakerPipelineParameters: Optional[SageMakerPipelineParameters]
    SqsParameters: Optional[SqsParameters]


REPEATED_INVOCATION = "repeated_invocation"

MATCHING_OPERATIONS = [
    "prefix",
    "cidr",
    "exists",
    "suffix",
    "anything-but",
    "numeric",
    "equals-ignore-case",
    "wildcard",
]


def extract_rule_name(rule_id: str) -> str:
    return rule_id.rsplit("|", maxsplit=1)[-1]


class EventsRuleProvider(ResourceProvider[EventsRuleProperties]):
    TYPE = "AWS::Events::Rule"  # Autogenerated. Don't change
    SCHEMA = util.get_schema_path(Path(__file__))  # Autogenerated. Don't change

    def create(
        self,
        request: ResourceRequest[EventsRuleProperties],
    ) -> ProgressEvent[EventsRuleProperties]:
        """
        Create a new resource.

        Primary identifier fields:
          - /properties/Id

        Create-only properties:
          - /properties/Name
          - /properties/EventBusName

        Read-only properties:
          - /properties/Id
          - /properties/Arn


        """
        model = request.desired_state
        events = request.aws_client_factory.events

        name = model.get("Name")
        if not name:
            name = util.generate_default_name(
                stack_name=request.stack_name, logical_resource_id=request.logical_resource_id
            )

        if event_bus_name := model.get("EventBusName"):
            model["Id"] = "|".join(
                [
                    event_bus_name,
                    name,
                ]
            )
        else:
            model["Id"] = name

        attrs = [
            "ScheduleExpression",
            "EventPattern",
            "State",
            "Description",
            "Name",
            "EventBusName",
        ]

        params = util.select_attributes(model, attrs)

        def wrap_in_lists(o, **kwargs):
            if isinstance(o, dict):
                for k, v in o.items():
                    if not isinstance(v, (dict, list)) and k not in MATCHING_OPERATIONS:
                        o[k] = [v]
            return o

        pattern = params.get("EventPattern")
        if isinstance(pattern, dict):
            wrapped = common.recurse_object(pattern, wrap_in_lists)
            params["EventPattern"] = json.dumps(wrapped)

        params["Name"] = name
        result = events.put_rule(**params)
        model["Arn"] = result["RuleArn"]

        # put targets
        event_bus_name = model.get("EventBusName")
        targets = model.get("Targets") or []

        if targets:
            put_targets_kwargs = {"Rule": extract_rule_name(model["Id"]), "Targets": targets}
            if event_bus_name:
                put_targets_kwargs["EventBusName"] = event_bus_name

            put_targets_kwargs = util.convert_request_kwargs(
                put_targets_kwargs,
                events.meta.service_model.operation_model("PutTargets").input_shape,
            )

            events.put_targets(**put_targets_kwargs)

        return ProgressEvent(
            status=OperationStatus.SUCCESS,
            resource_model=model,
            custom_context=request.custom_context,
        )

    def read(
        self,
        request: ResourceRequest[EventsRuleProperties],
    ) -> ProgressEvent[EventsRuleProperties]:
        """
        Fetch resource information


        """
        raise NotImplementedError

    def delete(
        self,
        request: ResourceRequest[EventsRuleProperties],
    ) -> ProgressEvent[EventsRuleProperties]:
        """
        Delete a resource


        """
        model = request.desired_state
        events = request.aws_client_factory.events

        rule_name = extract_rule_name(model["Id"])
        targets = events.list_targets_by_rule(Rule=rule_name)["Targets"]
        target_ids = [tgt["Id"] for tgt in targets]
        if targets:
            events.remove_targets(Rule=rule_name, Ids=target_ids, Force=True)
        events.delete_rule(Name=rule_name)

        return ProgressEvent(
            status=OperationStatus.SUCCESS,
            resource_model=model,
            custom_context=request.custom_context,
        )

    def update(
        self,
        request: ResourceRequest[EventsRuleProperties],
    ) -> ProgressEvent[EventsRuleProperties]:
        """
        Update a resource


        """
        raise NotImplementedError
