# AGENTS.md — LocalStack

LocalStack is a fully functional local AWS cloud stack that emulates AWS services (S3, Lambda, DynamoDB, etc.) for development and testing. It runs in Docker, provides AWS-like APIs locally, enabling offline workflows, integration testing, and CI without calling real AWS endpoints.

This is the **open-source community edition** (`localstack-core`). 

---

## Critical Hard Constraints

**NEVER:**
- Modify `*.snapshot.json` or `*.validation.json` files manually — generated by running tests against AWS
- Use plain `assert` in validated tests — **ALWAYS** use `snapshot.match()`
- Create AWS resources directly in test bodies — **ALWAYS** use fixtures
- Hardcode account IDs or region names — use `account_id` and `region_name` fixtures
- Modify files in `localstack-core/localstack/aws/api/` — auto-generated from AWS API definitions
- Add new project dependencies without approval
- Run `git push` or modify repository history

---

## Commands

```bash
# Development setup
make install           # Install dependencies with venv
make entrypoints       # Regenerate plugin entry points (required after adding plugins)
make start             # Start LocalStack in host mode

# Testing
pytest <path/to/test_file.py>                # Run test file
pytest <path/to/test_file.py> -k <test_name> # Run specific test
TEST_TARGET=AWS_CLOUD SNAPSHOT_UPDATE=1 pytest <path>  # Run against AWS to record snapshots

# Code quality
make lint              # Lint check
make format            # Format all
```

---

## Project Structure

```
localstack-core/
├── localstack/
│   ├── services/<service>/        # Service implementations
│   │   ├── provider.py            # API handlers (extends generated API stub)
│   │   └── models.py              # State stores (AccountRegionBundle pattern)
│   ├── aws/
│   │   ├── api/<service>/         # Auto-generated API types (DO NOT EDIT)
│   │   ├── protocol/              # Request/response marshalling
│   │   └── handlers/              # HTTP request handlers
│   ├── runtime/                   # LocalStack runtime components
│   ├── state/                     # State management and persistence
│   ├── testing/                   # Test infrastructure and fixtures
│   ├── utils/                     # Utility modules (.files, .json, .net, .strings, .sync, etc.)
│   ├── config.py                  # Configuration (environment variables)
│   └── plugins.py                 # Plugin management
tests/
├── aws/services/<service>/        # AWS service integration tests
├── unit/                          # Unit tests
├── integration/                   # Integration tests
└── conftest.py                    # Pytest configuration
docs/
├── localstack-concepts/           # Core architectural concepts
├── testing/                       # Testing documentation
└── CONTRIBUTING.md                # Contribution guidelines
```

### Moto Integration

LocalStack uses [`moto`](https://github.com/spulec/moto) as a backend for many services. You can:
- Use `call_moto(context)` to forward requests to moto implementations
- Use `MotoFallbackDispatcher` to wrap providers and forward unimplemented operations to moto
- Access moto backends directly for state: `from moto.sns import sns_backends`

---

## Implementing AWS Operations

### Reference Implementation

For a complete example of provider patterns, state management, and moto integration, see the **SNS** service:

- **Provider:** `localstack-core/localstack/services/sns/provider.py`
- **Models (state store):** `localstack-core/localstack/services/sns/models.py`

Refer to this implementation when:
- Creating a new service from scratch
- Understanding the `@handler` decorator pattern
- Learning the `AccountRegionBundle` state management pattern
- Implementing service-specific exceptions
- Using `call_moto(context)` for moto fallback

### Key Conventions

- **Types:** Import from `localstack.aws.api.<service>` (auto-generated, don't modify)
- **Errors:** Use service-specific exceptions from API module, or `CommonServiceException`
- **IDs:** Use `short_uid()` from `localstack.utils.strings`
- **ARNs:** Use helpers from `localstack.utils.aws.arns`
- **Logging:** `LOG = logging.getLogger(__name__)` at module top
- **Stores:** Use `AccountRegionBundle` pattern from `localstack.services.stores`

### Generating API Stubs

```bash
python -m localstack.aws.scaffold generate <service> --save [--doc]
```

This generates Python stubs from AWS Smithy specifications in `localstack/aws/api/<service>/`.

---

## Writing Parity Tests

### Reference Implementation

For complete examples of test patterns, fixtures, and snapshots, see the **SNS** tests:

- **Integration tests:** `tests/aws/services/sns/test_sns.py`
- **Fixtures (conftest):** `tests/aws/services/sns/conftest.py`

Refer to these when:
- Writing `@markers.aws.validated` tests with snapshot matching
- Creating fixture factories with cleanup
- Understanding the `@pytest.mark.parametrize` pattern
- Testing error cases with `pytest.raises` and `snapshot.match`

### Test Markers

Use `@markers.aws.validated` for tests that run against AWS (preferred), or `@markers.aws.only_localstack` for implementation-specific assertions.

### Core Patterns

```python
@markers.aws.validated
def test_create_topic_with_attributes(self, sns_create_topic, snapshot, aws_client):
    # Custom transformers for dynamic values
    snapshot.add_transformer(snapshot.transform.sns_api())

    # Use fixtures for resource creation
    create_topic = sns_create_topic(
        Name="topictest.fifo",
        Attributes={"FifoTopic": "true"},
    )
    topic_arn = create_topic["TopicArn"]

    # Match response against snapshot
    get_attrs_resp = aws_client.sns.get_topic_attributes(TopicArn=topic_arn)
    snapshot.match("get-topic-attrs", get_attrs_resp)

    # Test error cases
    with pytest.raises(ClientError) as e:
        aws_client.sns.get_topic_attributes(TopicArn="invalid-arn")
    snapshot.match("get-attrs-error", e.value.response)
```

### Fixture Rules

- **Return the entire response** from create operations
- **Store only names/ARNs** in cleanup list (not full responses)
- **Log cleanup errors** with `LOG.debug()` for debugging with `-s`
- **Use `yield`** for automatic cleanup after test completion

```python
@pytest.fixture
def sns_create_topic(aws_client):
    topic_arns = []

    def factory(**kwargs):
        if "Name" not in kwargs:
            kwargs["Name"] = f"test-topic-{short_uid()}"
        response = aws_client.sns.create_topic(**kwargs)
        topic_arns.append(response["TopicArn"])
        return response

    yield factory

    for topic_arn in topic_arns:
        try:
            aws_client.sns.delete_topic(TopicArn=topic_arn)
        except Exception:
            LOG.debug("Failed to delete topic %s", topic_arn)
```

### Transformers

Add transformers **before** `snapshot.match()` for non-deterministic values:

- **API transformer (preferred):** `snapshot.add_transformer(snapshot.transform.sns_api())`
- **By key:** `snapshot.add_transformer(snapshot.transform.key_value("TopicArn"))`
- **By regex:** `snapshot.add_transformer(snapshot.transform.regex(dynamic_value, "<placeholder>"))`
- **For sorting:** Use `SortingTransformer` from `localstack.testing.snapshots.transformer`

### Key Fixtures

- `aws_client` — Boto3 clients (e.g., `aws_client.s3`, `aws_client.lambda_`)
- `snapshot` — Snapshot matching and transformers
- `account_id`, `region_name` — Current account/region (never hardcode)
- `deploy_cfn_template` — Deploy CloudFormation with lifecycle management
- `cleanups` — Register arbitrary cleanup code for teardown

For common resource fixtures, check `localstack-core/localstack/testing/pytest/fixtures.py`

---

## Development Process

1. **Write a failing test first** — Capture AWS behavior with `TEST_TARGET=AWS_CLOUD SNAPSHOT_UPDATE=1`
2. **Find the provider** — Look in `localstack-core/localstack/services/<service>/provider.py`
3. **Check the store** — State issues often in `models.py`
4. **Compare with AWS docs** — Verify expected behavior
5. **Run test against LocalStack** — Ensure snapshot matches
6. **Iterate** — Run tests individually, see failures, fix, re-run

**Important:** When developing tests for functionality that doesn't exist in LocalStack yet, run tests against AWS to ensure validity. Don't run with `TEST_TARGET=LOCALSTACK` until the functionality exists.

---

## Testing Rules for Stability

| **Rule** | **Description** |
|----------|-----------------|
| R01 | Mark flaky tests with `@pytest.mark.skip(reason="flaky")` and notify code owners |
| R06 | Use `poll_condition()` instead of `time.sleep()` for async operations |
| R08 | Ensure features work with arbitrary account numbers (multi-account support) |
| R09 | Use randomized IDs (`short_uid()`) — tests must be idempotent and parallelizable |
| R10 | Use transformers to ensure deterministic snapshot comparisons |
| R13 | Always clean up resources using fixture teardown |
| R14 | Use appropriate fixture scopes (`function`, `class`, `session`) |

---

## Best Practices

### Always

- Run new tests against AWS first
- Use fixtures for resource creation with cleanup
- Add transformers for dynamic values
- Follow patterns in nearby existing code
- Use type hints
- Start simple (CRUD), then add edge cases, errors, pagination

### Avoid

- Over-commenting tests — test name and structure should be self-explanatory
- Adding comments for standard steps (transformers, snapshot matching)
- Creating new markers without discussion
- Using `time.sleep()` — use `poll_condition()` instead

---

## Reference

- **Testing Docs:** `docs/testing/README.md`
- **Architecture:** `docs/localstack-concepts/README.md`
- **Contributing:** `docs/CONTRIBUTING.md`
- **Common Fixtures:** `localstack-core/localstack/testing/pytest/fixtures.py`
- **Test Markers:** `localstack-core/localstack/testing/pytest/marking.py`
